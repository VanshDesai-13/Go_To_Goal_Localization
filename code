#include <Encoder.h>
#include <math.h>
#include <Wire.h>

const float Circumference = 0.187; 

const int PPR = 2500;

const float Ticks = PPR * 4.0;
float target_x = (2/0.187)*10000;
float target_y = (2/0.187)*10000;
float target_yaw=0;
float error_yaw;
const float Kpm=0.1,Kim,Kdm;
volatile float intw=0,derw=0;
float errorx;
float errory;
float w1,w2,w3,w4;
volatile float currentPositionx;
volatile float currentPositiony;
volatile float w;
float Kpx=5;
float Kpy=5,Kix=0,Kiy=0,Kdx=0,Kdy=0;
volatile float propx;
volatile float propy;
volatile float intx=0;
volatile float inty=0;
volatile float derx=0;
volatile float dery=0;
float prev_errorx=target_x;
float prev_errory=target_y;
float prev_error_yaw=target_yaw;
float R=2941.18;           // Radius of wheel
float lx=24064.17;
float ly=24064.17;

int motor_1pin_1 =7;  
int motor_1pin_2 =6;   
                         //Motor Driver 1
int motor_2pin_1 =5;    
int motor_2pin_2 =4;   

int motor_3pin_1 =11;  
int motor_3pin_2 = 12;   
                           //Motor Driver 2
int motor_4pin_1 = 10;   
int motor_4pin_2 = 9;  

Encoder myEnc1(18,19);
Encoder myEnc2(2, 3);

long oldPositionx = -999; 
long oldPositiony = -999; 

const int MPU_ADDR = 0x68;
float yaw = 0.0, gyro_z_offset = 0.0, prevYaw = 0.0, actual_yaw = 0.0;
unsigned long prevTime = 0;
const float alpha = 0.75;

void setup() {
  Serial.begin(115200);
  Wire.begin();
  Wire.beginTransmission(MPU_ADDR);
  if (Wire.endTransmission() != 0) {
     Serial.println("MPU6050 not found!");
     while (1); 
   }

  Wire.beginTransmission(MPU_ADDR);
  Wire.write(0x6B); 
  Wire.write(0); 
  Wire.endTransmission(true);

  long sum = 0;
  for (int i = 0; i < 200; i++)
  {
    sum += readGyroZ(); 
    delay(5); 
  }
  gyro_z_offset = sum / 200.0;
  //Serial.print("Calibration offset: "); 
  //Serial.println(gyro_z_offset);

  prevTime = micros();

  pinMode(motor_1pin_1,OUTPUT);
  pinMode(motor_1pin_2,OUTPUT);
  pinMode(motor_2pin_1,OUTPUT);
  pinMode(motor_2pin_2,OUTPUT);
  pinMode(motor_3pin_1,OUTPUT);
  pinMode(motor_3pin_2,OUTPUT);
  pinMode(motor_4pin_1,OUTPUT);
  pinMode(motor_4pin_2,OUTPUT);
}

void loop() {
  long newPositionx = myEnc1.read();
  long newPositiony = myEnc2.read();                                   
  float t1=millis();
  if (newPositionx != oldPositionx) 
   {
    oldPositionx = newPositionx;

    float revolutionsx = (float)newPositionx / Ticks;                  
    float distancex = revolutionsx * Circumference;

    // Serial.print("Ticks:");
    // Serial.print(newPositionx);
    // Serial.println("Distance: ");
    // Serial.print(distancex);
    }
    currentPositionx=newPositionx;
    errorx=target_x-currentPositionx; 
    // Serial.println("Errorx: ");
    // Serial.print(errorx);
  float t2=millis();
  float dtx=(t2-t1)/1000;
   propx=Kpx*errorx;
   intx = intx + Kix*errorx*dtx;
   derx= derx + (Kdx * (errorx-prev_errorx))/dtx;
   float vx=propx;//+ intx + derx;
  float t3=millis();
  if (newPositiony != oldPositiony){
    oldPositiony = newPositiony;

    float revolutionsy = (float)newPositiony / Ticks;          
    float distancey = revolutionsy * Circumference;

    // Serial.print("Ticks: ");
    // Serial.print(newPositiony);
    // Serial.println("Distance: ");
    // Serial.print(distancey);
  }
  currentPositiony=newPositiony;
    errory=target_y-currentPositiony; 
  // Serial.println("Errory: ");
  // Serial.print(errory);
  float t4=millis();     
   float dty=(t4-t3)/1000;
   propy=Kpy*errory;
   inty = inty + Kiy*errory*dty;
   dery= dery + (Kdy* (errory-prev_errory))/dty;
   float vy=propy;// + inty + dery;
  int16_t gz_raw = readGyroZ();
  float gz_rads = ((gz_raw - gyro_z_offset) / 131.0);

  unsigned long now = micros();
  float dt = (now - prevTime) / 1e6;  
  prevTime = now;
  yaw += gz_rads * dt;
  actual_yaw = alpha * yaw + (1 - alpha) * prevYaw;
  Serial.println("Actual yaw:");
  Serial.print(actual_yaw);
  prevYaw = yaw; 
  error_yaw=target_yaw-actual_yaw;
  float intw = intw + Kim*error_yaw*dt;
  float derw = derw + (Kdm*(error_yaw-prev_error_yaw))/dt;
  w= Kpm*error_yaw + intw + derw;
    w1= (1/R)*(vx-vy-(lx+ly)*0.5*w);
    w2= (1/R)*(vx+vy-(lx+ly)*0.5*w);
    w3= (1/R)*(vx-vy+(lx+ly)*0.5*w);
    w4= (1/R)*(vx+vy+(lx+ly)*0.5*w);
    float max1= max(fabs(w1),fabs(w2));
    float max2= max(fabs(w3),fabs(w4));
    float maxw= max(max1,max2);
    if(fabs(maxw)>500)
    {
     w1 = (w1* 500)/maxw;
     w2 = (w2* 500)/maxw;
     w3 = (w3* 500)/maxw;
     w4 = (w4* 500)/maxw;
    } 
     int w_wheel1 = int((fabs(w1)/500)*100);
     int w_wheel2 = int((fabs(w2)/500)*100);
     int w_wheel3 = int((fabs(w3)/500)*100);
     int w_wheel4 = int((fabs(w4)/500)*100);
    
    // if(fabs(errorx)<20 && fabs(errory)<20)
    // {
    //  Serial.print("STOP");
    //  analogWrite(motor_1pin_1,0);
    //  analogWrite(motor_2pin_1,0);
    //  analogWrite(motor_3pin_1,0);
    //  analogWrite(motor_4pin_1,0);
    // }
    //if(fabs(errorx)>0 || fabs(errory)>0)
    //{
    analogWrite(motor_1pin_1,w_wheel1);
    digitalWrite(motor_1pin_2,(w1<0));
    analogWrite(motor_2pin_1,w_wheel2);
    digitalWrite(motor_2pin_2,(w2<0));
    analogWrite(motor_3pin_1,w_wheel3);
    digitalWrite(motor_3pin_2,(w3<0));
    analogWrite(motor_4pin_1,w_wheel4);
    digitalWrite(motor_4pin_2,(w4<0));
    //}
    prev_errorx=errorx;
    prev_errory=errory;
    prev_error_yaw=error_yaw;
}

int16_t readGyroZ() {
  Wire.beginTransmission(MPU_ADDR);
  Wire.write(0x47); 
  Wire.endTransmission(false);
  Wire.requestFrom(MPU_ADDR, 2, true);
  return (Wire.read() << 8) | Wire.read();
}
