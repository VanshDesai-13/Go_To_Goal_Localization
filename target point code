#include <Encoder.h>
#include <math.h>
#include <Wire.h>

bool A, B, C, D;
double target_x =1;
double target_y =0;

volatile double error_x;
volatile double error_y;

volatile double W1, W2, W3, W4;
volatile double currentPosition_x;
volatile double currentPosition_y;

volatile double distance_x;
volatile double distance_y;

volatile double vx, vy;

volatile float w = 0;

double Kp =1.7, Ki = 0.075, Kd = 1;

volatile double propx;
volatile double propy;

volatile double integral_x;
volatile double integral_y;

volatile double der_x;
volatile double der_y;

volatile double prev_error_x;
volatile double prev_error_y;


float R = 0.05;  // Radius of wheel
float a = 0.225;

int motor_1pin_1 =11;
int motor_1pin_2 =12;

int motor_2pin_1 = 5;
int motor_2pin_2 = 4;

int motor_3pin_1 = 7;
int motor_3pin_2 = 6;

int motor_4pin_1 =10;
int motor_4pin_2 =9;

Encoder myEnc1(18, 19);
Encoder myEnc2(2, 3);

long oldPosition_x = -999;
long oldPosition_y = -999;

const int MPU_ADDR = 0x68;
volatile float yaw = 0.0, gyro_z_offset = 0.0, prevYaw = 0.0, actual_yaw = 0.0;
volatile float target_yaw = 90,error_yaw;
unsigned long prevTime = 0;
const float alpha = 0.75, Kpm = 7.0;

void setup() {
  Serial.begin(115200);
  Serial.print("start") ;

  Wire.begin();
  Serial.print("1") ;
  Wire.beginTransmission(MPU_ADDR);
  Serial.print("2") ;

  if (Wire.endTransmission() != 0) {
    Serial.println("enter lopped") ;
    Serial.println("MPU6050 not found!");
    while (1);
  }

  Serial.println("exit") ;

  Wire.beginTransmission(MPU_ADDR);
  Wire.write(0x6B);
  Wire.write(0);
  Wire.endTransmission(true);

  // delay(1000);

  long sum = 0;
  for (int i = 0; i < 200; i++)
  {
    sum += readGyroZ();
    delay(5);
  }
  gyro_z_offset = sum / 200.0;
  //Serial.print("Calibration offset: ");
  //Serial.println(gyro_z_offset);

  int prevTime = micros();
  // delay(3000);
  pinMode(motor_1pin_1, OUTPUT);
  pinMode(motor_1pin_2, OUTPUT);
  pinMode(motor_2pin_1, OUTPUT);
  pinMode(motor_2pin_2, OUTPUT);
  pinMode(motor_3pin_1, OUTPUT);
  pinMode(motor_3pin_2, OUTPUT);
  pinMode(motor_4pin_1, OUTPUT);
  pinMode(motor_4pin_2, OUTPUT);

  Serial.print("3") ;  
}

void loop() {

  int16_t gz_raw = readGyroZ();
  float gz_rads = ((gz_raw - gyro_z_offset) / 131.0) ;

  unsigned long now = micros();
  float dt = (now - prevTime) / 1e6;
  prevTime = now;
  yaw += gz_rads * dt;

  actual_yaw = alpha * yaw + (1 - alpha) * prevYaw;
  prevYaw = yaw;

  error_yaw = target_yaw - actual_yaw;
  // Serial.println("Yaw: ");
  // Serial.println(actual_yaw);
  w = Kpm* error_yaw * (PI/180.0);

  long newPosition_x = myEnc1.read();
  long newPosition_y = myEnc2.read();
  
  double t1 = millis();
  if (newPosition_x != oldPosition_x) {
    oldPosition_x = newPosition_x;
  }
 distance_x = newPosition_x * ((18.7) / 1000000.0);
  currentPosition_x = distance_x;

  error_x = target_x - currentPosition_x;
// Serial.print(200);
// Serial.print(",");
// Serial.print(distance_x);
// // Serial.print(",");
// // Serial.println(100);
// Serial.print(",");
// Serial.println(Kp);

  // Serial.println("start");
  // Serial.print(newPosition_x);
  // Serial.print(distance_x);
  // Serial.print(",");
  // Serial.print(error_x);
  // Serial.print(",");


  // Serial.println(newPosition_x);

  // Serial.println("Distance: ");
  // Serial.println(distance_x);
  // Serial.println("Error_x: ");
  // Serial.println(error_x);

  // delay(1000);

  double t2 = millis();
  double dt_x = (t2 - t1) / 1000;
  //propx=Kp*error_x;
  integral_x += error_x * dt_x;
  der_x = Kd * (error_x - prev_error_x) / dt_x;

  // volatile double vx = Kp*error_x + integral_x + der_x;
  vx = Kp * error_x + Ki * integral_x;

  double t3 = millis();

  if (newPosition_y != oldPosition_y) {
    oldPosition_y = newPosition_y;



    // Serial.print("Ticks: ");
    // Serial.print(newPositiony);
    // Serial.println("Distance: ");
    // Serial.print(distance_y);
  }

  distance_y = newPosition_y * ((18.7) / 1000000);

  currentPosition_y = distance_y;

  error_y = target_y - currentPosition_y;

  // Serial.println("start:");
  // Serial.print(error_y);
  // Serial.print(",");


  // Serial.println("Errory: ");
  // Serial.print(errory);
  double t4 = millis();
  double dt_y = (t4 - t3) / 1000;
  //   int16_t gz_raw = readGyroZ();
  // float gz_rads = ((gz_raw - gyro_z_offset) / 131.0) ;

  // unsigned long now = micros();
  // float dt = (now - prevTime) / 1e6;
  // prevTime = now;
  // yaw += gz_rads * dt;

  // actual_yaw = alpha * yaw + (1 - alpha) * prevYaw;
  // prevYaw = yaw;

  // Serial.print(90);
  // Serial.print(",");
  // Serial.print(actual_yaw);
  // Serial.print(",");
  // Serial.println(0);
  //propy=Kp*error_y;

  integral_y += error_y * dt_y;
  der_y = Kd * (error_y - prev_error_y) / dt_y;

  // double vy= Kp*error_y + integral_y + der_y;

  vy = Kp * error_y + Ki * integral_y + der_y;



  W1 = ((vx - vy - a * w) / (R * 2 * sqrt(2)))*(30.0/PI);
  W2 = ((vx + vy - a * w) / (R * 2 * sqrt(2)))*(30.0/PI);
  W3 = ((vx - vy + a * w) / (R * 2 * sqrt(2)))*(30.0/PI);
  W4 = ((vx + vy + a * w) / (R * 2 * sqrt(2)))*(30.0/PI);

  // Serial.print(W1);
  // Serial.print(",");
  // Serial.print(W2);
  // Serial.print(",");
  // Serial.print(W3);
  // Serial.print(",");
  // Serial.print(W4);

  double max1 = max(W1, W2);
  double max2 = max(W3, W4);
  double maxw = max(max1, max2);
  if (maxw > 400) {
    W1 = (W1 * 400) / maxw;
    W2 = (W2 * 400) / maxw;
    W3 = (W3 * 400) / maxw;
    W4 = (W4 * 400) / maxw;
  }

  if (W1 < 0) {
    A = false;
  } else if (W1 > 0) {
    A = true;
  }
  if (W2 < 0) {
    B = false;
  } else if (W2 > 0) {
    B = true;
  }
  if (W3 < 0) {
    C = false;
  } else if (W3 > 0) {
    C = true;
  }
  if (W4 < 0) {
    D = false;
  } else if (W4 > 0) {
    D = true;
  }



  double w_wheel1 = ((fabs(W1) / (750.0*V)/18.0) * 255);
  double w_wheel2 = ((fabs(W2) / (750.0*V)/18.0) * 255);
  double w_wheel3 = ((fabs(W3) / (750.0*V)/18.0) * 255);
  double w_wheel4 = ((fabs(W4) / (750.0*V)/18.0) * 255);

  // delay(1000);
  // Serial.print(w_wheel1);
  // Serial.print(",");
  // Serial.print(w_wheel2);
  // Serial.print(",");
  // Serial.print(w_wheel3);
  // Serial.print(",");
  // Serial.print(w_wheel4);

  // && error_y <= 5 && error_y >= -5)
  if (error_x == 0 && error_x == 0) {
    //  Serial.print("STOP");
    analogWrite(motor_1pin_1, 0);
    analogWrite(motor_2pin_1, 0);
    analogWrite(motor_3pin_1, 0);
    analogWrite(motor_4pin_1, 0);
  } else {
    analogWrite(motor_1pin_1, w_wheel1);
    digitalWrite(motor_1pin_2, A);
    analogWrite(motor_2pin_1, w_wheel2);
    digitalWrite(motor_2pin_2, B);
    analogWrite(motor_3pin_1, w_wheel3);
    digitalWrite(motor_3pin_2, C);
    analogWrite(motor_4pin_1, w_wheel4);
    digitalWrite(motor_4pin_2, D);
  }
  // delay(1000);

  prev_error_x = error_x;
  prev_error_y = error_y;

  //   int16_t gz_raw = readGyroZ();
  // float gz_rads = ((gz_raw - gyro_z_offset) / 131.0) ;

  // unsigned long now = micros();
  // float dt = (now - prevTime) / 1e6;
  // prevTime = now;
  // yaw += gz_rads * dt;

  // actual_yaw = alpha * yaw + (1 - alpha) * prevYaw;
  // prevYaw = yaw;

  // Serial.print(-180);
  // Serial.print(" ");
  // Serial.print(actual_yaw, 6);
  // Serial.print(" ");
  // Serial.println(180);
  // delay(100);

  Serial.print(der_x);
  Serial.print(",");
  Serial.print(error_x);
  Serial.print(",");
  Serial.print(prev_error_x);
}

int16_t readGyroZ() {
  Wire.beginTransmission(MPU_ADDR);
  Wire.write(0x47);
  Wire.endTransmission(false);
  Wire.requestFrom(MPU_ADDR, 2, true);
  return (Wire.read() << | Wire.read());
}
